<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Technical Documentation Page</title>
    <link
      href="https://fonts.googleapis.com/css?family=Ubuntu+Mono|Yantramanav&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <main id="main-doc">
      <!--SECTION 1 - useState-->
      <section class="main-section" id="useState">
        <header>useState</header>
        <code
          ><span class="code__const">const</span> [state, setState] =
          <span class="code__method">useState</span>(initialState);
        </code>
        <p>Returns a stateful value, and a function to update it.</p>
        <p>
          During the initial render, the returned state (<span
            class="code_in_text"
            >state</span
          >) is the same as the value passed as the first argument (<span
            class="code_in_text"
            >initialState</span
          >).
        </p>
        <p>
          The <span class="code_in_text">setState</span> function is used to
          update the state. It accepts a new state value and enqueues a
          re-render of the component.
        </p>
        <code> <span class="code__method">setState</span>(newState);</code>
        <p>
          During subsequent re-renders, the first value returned by
          <span class="code_in_text">useState</span> will always be the most
          recent state after applying updates.
        </p>
        <div class="note">
          <h3>Note</h3>
          React guarantees that
          <span class="code_in_text">setState</span> function identity is stable
          and won’t change on re-renders. This is why it’s safe to omit from the
          <span class="code_in_text">useEffect</span> or
          <span class="code_in_text">useCallback</span> dependency list.
        </div>
      </section>
      <!--SECTION 2 - useEffect-->
      <section class="main-section" id="useEffect">
        <header>useEffect</header>
        <code><span class="code__method">useEffect</span>(didUpdate);</code>
        <p>
          Accepts a function that contains imperative, possibly effectful code.
        </p>
        <p>
          Mutations, subscriptions, timers, logging, and other side effects are
          not allowed inside the main body of a function component (referred to
          as React’s render phase). Doing so will lead to confusing bugs and
          inconsistencies in the UI.
        </p>
        <p>
          Instead, use <span class="code_in_text">useEffect</span>. The function
          passed to <span class="code_in_text">useEffect</span> will run after
          the render is committed to the screen. Think of effects as an escape
          hatch from React’s purely functional world into the imperative world.
        </p>
        <p>
          By default, effects run after every completed render, but you can
          choose to fire it only when certain values have changed.
        </p>
      </section>
      <!--SECTION 3 - useContext-->
      <section class="main-section" id="useContext">
        <header>useContext</header>
        <code>
          <span class="code__const">const</span> value =
          <span class="code__method">useContext</span>(MyContext);
        </code>
        <p>
          Accepts a context object (the value returned from
          <span class="code_in_text">React.createContext</span>) and returns the
          current context value for that context. The current context value is
          determined by the <span class="code_in_text">value</span> prop of the
          nearest
          <span class="code_in_text">&lt;MyContext.Provider&gt;</span> above the
          calling component in the tree.
        </p>
        <p>
          When the nearest
          <span class="code_in_text">&lt;MyContext.Provider&gt;</span> above the
          component updates, this Hook will trigger a rerender with the latest
          context <span class="code_in_text">value</span> passed to that
          MyContext provider.
        </p>
      </section>
      <!--SECTION 4 - useReducer-->
      <section class="main-section" id="useReducer">
        <header>useReducer</header>
        <code>
          <span class="code__const">const</span> [state, dispatch] =
          <span class="code__method">useReducer</span>(reducer, initialArg,
          init);
        </code>
        <p>
          An alternative to useState. Accepts a reducer of type
          <span class="code_in_text">(state, action) => newState</span>, and
          returns the current state paired with a
          <span class="code_in_text">dispatch</span>
          method. (If you’re familiar with Redux, you already know how this
          works.)
        </p>
        <p>
          <span class="code_in_text">useReducer</span> is usually preferable to
          <span class="code_in_text">useState</span> when you have complex state
          logic that involves multiple sub-values or when the next state depends
          on the previous one. <span class="code_in_text">useReducer</span> also
          lets you optimize performance for components that trigger deep updates
          because you can pass dispatch down instead of callbacks.
        </p>
      </section>
      <!--SECTION 5 - useCallback-->
      <section class="main-section" id="useCallback">
        <header>useMemo</header>
        <code>
          <span class="code__const">const</span> memoizedValue =
          <span class="code__method">useMemo</span>(() =>
          <span class="code__method">computeExpensiveValue</span>(a, b), [a,
          b]);
        </code>
        <p>
          Returns a memoized value.
        </p>
        <p>
          Pass a “create” function and an array of dependencies.
          <span class="code_in_text">useMemo</span> will only recompute the
          memoized value when one of the dependencies has changed. This
          optimization helps to avoid expensive calculations on every render.
        </p>
        <p>
          Remember that the function passed to
          <span class="code_in_text">useMemo</span> runs during rendering. Don’t
          do anything there that you wouldn’t normally do while rendering. For
          example, side effects belong in
          <span class="code_in_text">useEffect</span>, not
          <span class="code_in_text">useMemo</span>.
        </p>
        <p>
          If no array is provided, a new value will be computed on every render.
        </p>
      </section>
    </main>
  </body>
</html>
